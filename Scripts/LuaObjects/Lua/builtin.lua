---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by michieal.
--- DateTime: 10/11/23 5:28 PM
---

local function dumpTable(table, depth)
    if (depth > 200) then
        print("Error: Depth > 200 in dumpTable()")
        return
    end
    for k, v in pairs(table) do
        if (type(v) == "table") then
            print(string.rep("  ", depth) .. k .. ":")
            dumpTable(v, depth + 1)
        else
            print(string.rep("  ", depth) .. k .. ": ", v)
        end
    end
end

function dump(table)
    dumpTable(table, 199)
end

function S(strText)
    return strText
end

function minetest.get_node(pos)
    return pos
end

local BAMBOO = "bamboo"

local test_def = {
    description = S("Bamboo"),
    tiles = { "mcl_bamboo_bamboo_bottom.png", "mcl_bamboo_bamboo_bottom.png", "mcl_bamboo_bamboo.png" },
    drawtype = "nodebox",
    paramtype = "light",
    groups = { handy = 1, axey = 1, choppy = 1, dig_by_piston = 1, plant = 1, non_mycelium_plant = 1, flammable = 3 },
    sounds = node_sound,

    drop = {
        max_items = 1,
        -- From the API:
        -- max_items: Maximum number of item lists to drop.
        -- The entries in 'items' are processed in order. For each:
        -- Item filtering is applied, chance of drop is applied, if both are
        -- successful the entire item list is dropped.
        -- Entry processing continues until the number of dropped item lists
        -- equals 'max_items'.
        -- Therefore, entries should progress from low to high drop chance.
        items = {
            -- Examples:
            {
                -- 1 in DOUBLE_DROP_CHANCE chance of dropping.
                -- Default rarity is '1'.
                rarity = DOUBLE_DROP_CHANCE,
                items = { BAMBOO .. " 2" },
            },
            {
                -- 1 in 1 chance of dropping. (Note: this means that it will drop 100% of the time.)
                -- Default rarity is '1'.
                rarity = 1,
                items = { BAMBOO },
            },
        },
    },

    inventory_image = "mcl_bamboo_bamboo_shoot.png",
    wield_image = "mcl_bamboo_bamboo_shoot.png",
    _mcl_blast_resistance = 1,
    _mcl_hardness = 1.5,
    node_box = {
        type = "fixed",
        fixed = {
            { -0.175, -0.5, -0.195, 0.05, 0.5, 0.030 },
        }
    },
    collision_box = {
        type = "fixed",
        fixed = {
            { -0.175, -0.5, -0.195, 0.05, 0.5, 0.030 },
        }
    },
    selection_box = {
        type = "fixed",
        fixed = {
            { -0.175, -0.5, -0.195, 0.05, 0.5, 0.030 },
        }
    },
    node_placement_prediction = "",

    on_rotate = on_rotate,

    on_place = function(itemstack, placer, pointed_thing)
        if pointed_thing.type ~= "node" then
            return itemstack
        end
        local node = minetest.get_node(pointed_thing.under)
        local pos = pointed_thing.under
        local nodename = node.name -- intentional use of nodename.

        mcl_bamboo.mcl_log("Node placement data:")
        mcl_bamboo.mcl_log(dump(pointed_thing))
        mcl_bamboo.mcl_log("node name: " .. nodename)

        mcl_bamboo.mcl_log("Checking for protected placement of bamboo.")
        if mcl_bamboo.is_protected(pos, placer) then
            return
        end
        mcl_bamboo.mcl_log("placement of bamboo is not protected.")

        -- Use pointed node's on_rightclick function first, if present
        if placer and not placer:get_player_control().sneak then
            if minetest.registered_nodes[node.name] and minetest.registered_nodes[node.name].on_rightclick then
                mcl_bamboo.mcl_log("Attempting targeted node's on_rightclick.")
                return minetest.registered_nodes[node.name].on_rightclick(pointed_thing.under, node, placer, itemstack) or itemstack
            end
        end

        if mcl_bamboo.is_bamboo(nodename) == false and nodename ~= BAMBOO_ENDCAP_NAME then
            -- not bamboo...
            mcl_bamboo.mcl_log("not bamboo...")
            if nodename ~= "mcl_flowerpots:flower_pot" then
                if mcl_bamboo.is_dirt(nodename) == false then
                    mcl_bamboo.mcl_log("bamboo dirt node not found; node name: " .. nodename)
                    return
                end
            end
        end

        mcl_bamboo.mcl_log("placing bamboo directly.")

        local dir = vector.subtract(pointed_thing.under, pointed_thing.above)
        local wdir = minetest.dir_to_wallmounted(dir)
        local fdir = minetest.dir_to_facedir(dir)
        if wdir ~= 1 then
            return
        end

        local place_item = ItemStack(itemstack) -- make a copy so that we don't indirectly mess with the original.

        local bamboo_node = mcl_bamboo.is_bamboo(nodename) or 0
        mcl_bamboo.mcl_log("node name: " .. nodename .. "\nbamboo_node: " .. bamboo_node)

        local rand_height
        local BAMBOO_MAX_HEIGHT = 16 -- maximum height of 16, per wiki.
        local first_shoot
        local meta

        if bamboo_node and bamboo_node > 0 then
            place_item = ItemStack(mcl_bamboo.bamboo_index[bamboo_node])

            -- height check for placing bamboo nodes. because... lmfao bamboo stalk to the sky.
            -- variables used in more than one spot.
            local chk_pos
            local node_name = ""
            local dist = 0
            local height = -1

            local BAMBOO_SOIL_DIST = BAMBOO_MAX_HEIGHT * -1
            -- -------------------
            for py = -1, BAMBOO_SOIL_DIST, -1 do
                chk_pos = vector.offset(pos, 0, py, 0)
                node_name = minetest.get_node(chk_pos).name
                if mcl_bamboo.is_dirt(node_name) then
                    first_shoot = vector.offset(chk_pos, 0, 1, 0)
                    break
                end
                if mcl_bamboo.is_bamboo(node_name) == false then
                    break
                end
            end
            -- requires knowing where the soil node is.
            if first_shoot == nil then
                return
            end
            meta = minetest.get_meta(first_shoot)
            if meta then
                height = meta:get_int("height", -1)
            end

            dist = vector.distance(first_shoot, pos) + 1 -- +1 for the ground offset.
            mcl_bamboo.mcl_log("Distance: " .. dist .. " Height: " .. height .. " Bamboo to place: " .. mcl_bamboo.bamboo_index[bamboo_node])
            -- okay, so don't go beyond max height...
            -- Height is determined when the first node grows or is placed.
            -- here, it's not found, so let them do 4-5 nodes up. (should help it grow.)
            if dist < 5 and height < 5 then
                -- allow
            else
                -- else, it's complicated.
                if dist > 5 and height < 5 then
                    return
                end
            end

            if dist > height - 1 then
                -- height found. here, we let them do it until they reach where the endcap will go.
                return
            end
        else
            local placed_type = pr:next(1, 4) -- randomly choose which one to place.
            mcl_bamboo.mcl_log("Place_Bamboo_Shoot--Type: " .. placed_type)
            place_item = ItemStack(mcl_bamboo.bamboo_index[placed_type])
            rand_height = pr:next(BAMBOO_MAX_HEIGHT - 4, BAMBOO_MAX_HEIGHT)
        end

        local node_above_name = minetest.get_node(pointed_thing.above).name
        mcl_bamboo.mcl_log("\n\n\nnode_above name: " .. node_above_name)
        if node_above_name ~= "mcl_core:water_source" and node_above_name ~= "mcl_core:lava_source"
                and node_above_name ~= "mcl_nether:nether_lava_source" then
            local _, position = minetest.item_place(place_item, placer, pointed_thing, fdir)
            if position then
                if not minetest.is_creative_enabled(placer:get_player_name()) then
                    itemstack:take_item(1)
                end
                if rand_height and rand_height > 1 then
                    mcl_bamboo.mcl_log("Setting Height Data...")
                    meta = minetest.get_meta(position)
                    if meta then
                        meta:set_int("height", rand_height)
                    end
                end
            end
            return itemstack, pointed_thing.under
        else
            return
        end
    end,

    on_destruct = function(pos)
        -- Node destructor; called before removing node.
        local new_pos = vector.offset(pos, 0, 1, 0)
        local node_above = minetest.get_node(new_pos)
        local bamboo_node = mcl_bamboo.is_bamboo(node_above.name) or 0
        local istack = ItemStack(BAMBOO)
        local sound_params = {
            pos = new_pos,
            gain = 1.0, -- default
            max_hear_distance = 10, -- default, uses a Euclidean metric
        }

        if node_above and ((bamboo_node and bamboo_node > 0) or node_above.name == BAMBOO_ENDCAP_NAME) then
            minetest.remove_node(new_pos)
            minetest.sound_play(node_sound.dug, sound_params, true)
            if pr:next(1, DOUBLE_DROP_CHANCE) == 1 then
                minetest.add_item(new_pos, istack)
            end
            minetest.add_item(new_pos, istack)
        end
    end,
}

-- dump(test_def)

print("this is a test of the external revenue system.")

myvar = {}

mclpp.register_abm({
    label = "Break Orphaned Bamboo",
    nodenames = { "bamboo_node" }, --mcl_bamboo.bamboo_index
    interval = 10.5,
    chance = 1,
    action = function(pos, _)
        print("From BuiltIn: Break Orphaned Bamboo was called")
        -- mcl_bamboo.break_orphaned(pos)
    end,
})